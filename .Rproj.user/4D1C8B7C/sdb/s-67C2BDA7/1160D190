{
    "contents" : "# Author: Brian Waismeyer\n# Contact: bwaismeyer@gmail.com\n\n# Date created: 3/23/2015\n# Date updated: 7/8/2015\n\n###############################################################################\n## SCRIPT OVERVIEW\n\n# GOAL: server.R is a core Shiny project file that generates and manages data\n#       objects and user interactions with these objects. The user-facing\n#       displays of these data objects and the points of interaction are\n#       arranged in ui.R.\n#\n#       For the Multinomial Outcome Simulator (MOS) application, the server.R\n#       file handles the processing of a given model formula and data to\n#       generate outcome-likelihood visualizations, along with the variety\n#       of intermediate products needed to get those visualizations.\n#\n#       NOTE: Because ui.R is run before server.R, this application has been \n#       designed so that all resources needed for server.R are loaded in ui.R.\n#\n# SCRIPT OUTLINE:\n# - Server Initialization (Steps That Don't Need To Be Reactive)\n#   - Anything placed in this section will be processed only the when the server\n#     is initialized. It is the place to define the point MOS users should\n#     start from when they connect to the application.\n#   - We need to \"spread\" the factors and interactions in a second data frame  \n#     so they are handled properly; this also results in an expanded model\n#     formula matching the \"spread\" data frame.\n#   - The first data frame is retained for factor/level information, the second\n#     is the data frame we will use for the model fitting and simulation.\n#   - We identify interaction columns in the expanded data.\n#   - We re-sample the model coefficients many times to get a set of estimates\n#     of these coefficients. This is the set that we will pass our\n#     counterfactual cases through.\n#\n# - shinyServer Loop (Steps That Do Need To Be Reactive)\n#   - This is where the bulk of the action takes place - it handles all of the\n#     simulation steps that need to be responsive to user input, all of the\n#     visualization steps, and also contributes to the creation of dynamic\n#     parts of the UI. It proceeds roughly as follows:\n#   - Collect user inputs.\n#   - Update the dynamic parts of the UI.\n#   - Create the base counterfactual case set.\n#   - Update the counterfactual case set based on user inputs.\n#   - Pass the counterfactual cases through the sampled coefficients to get\n#     outcome likelihoods for each case.\n#   - Generate the visualizations of the outcome likelihoods for the\n#     counterfactual cases.\n\n###############################################################################\n## Server Initialization (Steps That Don't Need To Be Reactive)\n\n# TESTING SETTINGS TO INCREASE STABILITY ## TEMP ##\n# options(warn = -1)\n\n# snag the outcome variable from the formula (simplifies later calls)\noutcome_variable <<- as.character(base_formula[[2]])\n\n# flip the formula to a character vector so we can use this vector to subset the\n# dataframe so that any unused variables are dropped\nchar_bf <- paste0(as.character(base_formula[2:3]), collapse = \"~\")\n# split the character string into individual terms (may include interactions)\nchar_bf <- strsplit(char_bf, \"\\\\+|\\\\~\")\n# drop any white space around the terms and force the result to be a vector\n# of terms\nchar_bf <- as.vector(sapply(char_bf, trimws))\n# drop any interaction terms\nchar_bf <- char_bf[!grepl(\"\\\\*|\\\\:\", char_bf)]\n# subset the dataframe\nbase_data <- base_data[char_bf]\n\n# expand the factors in the data object, re-add the outcome, drop the intercept\nexp_data <<- model.matrix(base_formula, base_data)\nexp_data <<- data.frame(base_data[outcome_variable],  \n                        exp_data)\nexp_data[, \"X.Intercept.\"] <<- NULL\n\n# fit the model to the expanded dataset (using the expanded model)\n# multinom: \"fit a multinomial log-linear model via neural networks\"\nexp_model <<- multinom(formula(exp_data), data = exp_data, Hess = T)\n\n# extract the interaction column names from the expanded data\ninteraction_cols <<- get_interaction_col_names(base_formula, exp_data)\n\n# get the static simulation/visualization features\npoint_estimates <<- get_point_estimates(exp_model)\ncov_matrix <<- get_covariance_matrix(exp_model)\ncoeff_estimates <<- get_coefficient_estimates(1000, point_estimates, \n                                              cov_matrix, exp_model)\n\n###############################################################################\n## shinyServer Loop (Steps That Need To Be Reactive)\n\nshinyServer(function(input, output, session) {\n    ## Collect user inputs.\n    # all are reactive objects so that updates to these can be relied on to\n    # update any dependencies\n    x_axis_raw_name <- reactive({\n        # explore raw_pretty_pairs to find the correct raw name\n        index <- match(input$x_axis_choice, raw_pretty_pairs)\n        raw_name <- names(raw_pretty_pairs)[index]\n        return(raw_name)\n    })\n    \n    facet_raw_name <- reactive({\n        # filter the variable_configuration dataframe for the row with the\n        # matching UI name, extract the column name\n        # UNLESS special variable \"None\" is selected, in which case return NULL\n        if(input$facet_choice == \"No Comparison Selected\") {\n            return(NULL)\n        } else {\n            # explore raw_pretty_pairs to find the correct raw name\n            index <- match(input$facet_choice, raw_pretty_pairs)\n            raw_name <- names(raw_pretty_pairs)[index]\n            return(raw_name)\n        }\n    })\n    \n    ## Update the dynamic parts of the UI.\n    # generate the input set (sliders only) for the \"Explore Mode\"\n    output$explore_slider_set <- renderUI({\n        # establish a reactive link to the \"Reset\" button - if this button is\n        # triggered the inputs will be recreated (resetting them to their \n        # default values)\n        input$reset_explore_inputs\n        \n        # make the inputs\n        make_inputs(variable_config_list = variable_configuration,\n                    variables_to_drop = x_axis_raw_name(),\n                    append_name = \"explore\",\n                    return_sliders = TRUE,\n                    return_facets = FALSE)\n    })\n    \n    # generate the input sets (sliders + dropdowns) for the \"Single Case Mode\"\n    output$sc_slider_set <- renderUI({\n        # establish a reactive link to the \"Reset\" button - if this button is\n        # triggered the inputs will be recreated (resetting them to their \n        # default values)\n        input$reset_sc_inputs\n        \n        # make the inputs\n        make_inputs(variable_config_list = variable_configuration,\n                    variables_to_drop = NA,\n                    append_name = \"sc\",\n                    return_sliders = TRUE,\n                    return_facets = FALSE)\n    })\n    \n    output$sc_dropdown_set <- renderUI({\n        # establish a reactive link to the \"Reset\" button - if this button is\n        # triggered the inputs will be recreated (resetting them to their \n        # default values)\n        input$reset_sc_inputs\n        \n        # make the inputs\n        make_inputs(variable_config_list = variable_configuration,\n                    variables_to_drop = NA,\n                    append_name = \"sc\",\n                    return_sliders = FALSE,\n                    return_facets = TRUE)\n    })\n    \n    # enable/disable update/simulate button for for \"Explore Mode\"\n    observeEvent(\n        return_inputs(variable_config_list = variable_configuration,\n                      input_call = input,               \n                      append_name = \"explore\",\n                      base_data = base_data,\n                      use_slider_values = TRUE,\n                      use_dropdown_values = FALSE,\n                      variables_to_drop = isolate(x_axis_raw_name())),\n        \n        ({updateButton(session, \"update_explore_cf_cases\",\n                       label = \"Apply Slider Values\",\n                       disabled = FALSE,\n                       style = \"danger\")\n        })\n    )\n    \n    observeEvent(\n        input$update_explore_cf_cases,\n        \n        ({updateButton(session, \"update_explore_cf_cases\",\n                       label = \"Plot Updated\",\n                       disabled = TRUE,\n                       style = \"success\")\n          \n        })\n    )\n    \n    # enable/disable update/simulate button for \"Single Case Mode\"\n    observeEvent(\n        return_inputs(variable_config_list = variable_configuration,\n                      input_call = input,               \n                      append_name = \"sc\",\n                      base_data = base_data,\n                      use_slider_values = TRUE,\n                      use_dropdown_values = TRUE),\n        \n        ({if(isolate(input$update_sc_cf_cases) == 0) {\n            updateButton(session, \"update_sc_cf_cases\",\n                         label = \"Simulate\",\n                         disabled = FALSE,\n                         style = \"danger\")\n        } else {\n            updateButton(session, \"update_sc_cf_cases\",\n                         label = \"Re-Simulate\",\n                         disabled = FALSE,\n                         style = \"danger\")\n        }\n        })\n    )\n    \n    observeEvent(\n        input$update_sc_cf_cases,\n        \n        ({updateButton(session, \"update_sc_cf_cases\",\n                       label = \"Simulation Updated\",\n                       disabled = TRUE,\n                       style = \"success\")\n          \n        })\n    )\n    \n    # on reset, force the Single Case mode input panels open so that all\n    # values reset correctly\n    observeEvent(\n        input$reset_sc_inputs,\n        \n        ({\n            updateCollapse(session, \"sc_panels\",\n                           open = c(\"Numeric Features\",\n                                    \"Categorical Features\")\n            )\n        })\n    )\n    \n    # construct the summary text for the ribbon plot (\"Explore Mode\")\n    output$ribbon_text <- renderText({\n        build_ribbon_summary(x_axis_raw_name(), \n                             facet_raw_name(),\n                             variable_configuration,\n                             # if \"Advanced Options\" are open, we want to drop\n                             # the plot summary\n                             include_plot_summary = is.null(input$adv_options))\n        \n    })\n        \n    ## Create the base counterfactual case set.\n    base_cf_cases <- reactive({\n        get_cf_cases(exp_data,\n                     base_data,\n                     exp_model, \n                     x_axis_raw_name(), \n                     facet_selected = facet_raw_name(),\n                     interaction_col_names = interaction_cols)\n    })\n    \n    ## Update the counterfactual case set based on user inputs.\n    # update for the \"Explore Mode\" visualizations\n    explore_cf_cases <- reactive({\n        # establish the reactive link to the \"Update\" button\n        input$update_explore_cf_cases\n        \n        # this next section only gets evaluated if the \"Show sliders?\" option is\n        # set to TRUE - in that case, the slider values will be used to \n        # create an updated data object each time the \"UPDATE PLOT\" button is\n        # clicked\n        # NOTE: the \"Update Plot\" button will only be visible if the \"Show\n        #       sliders?\" option is set to true, so we are restricting our\n        #       update pathways to just TWO possibilities:\n        #       1. the \"Update Plot\" button is visible and is pressed, updating \n        #          the data with slider values\n        #       2. a new x-axis is selected (refreshes the plots that use\n        #          explore_cf_cases() and resets the sliders if they are \n        #          visible)\n        # because \"input$adv_options\" is not isolated, we also get the desired\n        # behavior that the data is restored to its default state if the\n        # \"Advanced Options\" panel is collapsed\n        if(!is.null(input$adv_options) & input$update_explore_cf_cases > 0) {\n            # note that the update_target here is allowed to be reactive\n            # to create a reactive link when the sliders are visible\n            apply_input_values(update_target = base_cf_cases(), \n                               interaction_col_names = interaction_cols,\n                               variable_config_list = variable_configuration,\n                               input_call = isolate(input),               \n                               append_name = \"explore\",\n                               base_data = base_data,\n                               use_slider_values = TRUE,\n                               use_dropdown_values = FALSE,\n                               variables_to_drop = isolate(x_axis_raw_name()))\n        } else {\n            # reactive link for when the sliders are hidden\n            return(base_cf_cases())\n        }\n    })\n    \n    # update for the \"Single Case\" visualizations\n    sc_cf_cases <- reactive({        \n        # establish the reactive link to the \"Update\" button\n        input$update_sc_cf_cases\n        \n        # make the sliders\n        # NOTE: there is only a single reactive pathway here - the \"update_sc_\n        #       cf_cases\" input must be triggered - this insures that the\n        #       visualization chain is only triggered on user request        \n        apply_input_values(update_target = isolate(base_cf_cases()), \n                           interaction_col_names = interaction_cols,\n                           variable_config_list = variable_configuration,\n                           input_call = isolate(input),               \n                           append_name = \"sc\",\n                           base_data = base_data,\n                           use_slider_values = TRUE,\n                           use_dropdown_values = TRUE,\n                           variables_to_drop = NA)\n    })\n    \n    ## Pass the counterfactual cases through the sampled coefficients to get\n    ## outcome likelihoods for each case.\n    # get the \"Explore Mode\" likelihoods (note that these are actually \n    # summaries of the many likelihood sets generated for each case)\n    explore_likelihoods <- reactive({\n        # get the unformatted summary likelihoods\n        likelihoods_raw <- MOS_mlogitsimev(explore_cf_cases(), \n                                           coeff_estimates, \n                                           ci = c(0.95, 0.50))\n        \n        # format the summary likelihoods for visualization\n        ribbon_ready <- format_for_ribbon_plot(likelihoods_raw,\n                                               exp_model,\n                                               base_data,\n                                               isolate(explore_cf_cases()),\n                                               isolate(x_axis_raw_name()),\n                                               facet_selected = \n                                                   isolate(facet_raw_name())\n        )\n        \n        # return the formatted object\n        return(ribbon_ready)\n    })\n    \n    # get the \"Single Case Mode\" likelihoods (note that here we retain all the\n    # likelihood sets for just the first case; this works because all of the\n    # cases are actually identical in single case - we don't want summarized\n    # values per case, we want the raw likelihoods associated with each\n    # coefficient set for our specific example case)\n    sc_likelihoods <- reactive({\n        # get the estimates for each coefficient set for just the first case\n        likelihoods_cloud <- MOS_mlogitsimev(sc_cf_cases(), \n                                             coeff_estimates, \n                                             ci = c(0.95, 0.50),\n                                             return_first_case_likelihoods = \n                                                 TRUE)\n        \n        # format the single point estimates for visualization\n        likelihoods_cloud <- data.frame(likelihoods_cloud)\n        names(likelihoods_cloud) <- exp_model$lab\n        likelihoods_cloud$index <- 1:nrow(likelihoods_cloud)\n        dotplot_ready <- gather(likelihoods_cloud, outcome, single_pe, \n                                -index)\n        \n        # return the collection\n        return(dotplot_ready)\n    })\n    \n    ## Generate the visualizations of the outcome likelihoods for the\n    ## counterfactual cases.\n    # \"Explore Mode\" ribbon plot\n    output$ribbon_plot <- renderPlot({\n        # isolate the x_axis_variable name and its associated transform_for_ui\n        x_axis_var <- isolate(x_axis_raw_name())\n        ui_transform <- variable_configuration[[x_axis_var]]$transform_for_ui\n        \n        # apply the transform to the predictor column in explore_likelihoods to \n        # make it ui friendly\n        ribbon_likelihoods <- explore_likelihoods()\n        ribbon_likelihoods$predictor <- \n            ui_transform(ribbon_likelihoods$predictor)\n        \n        # draw the plot\n        rp <- get_ribbon_plot(ribbon_likelihoods, \n                        facet_selected = isolate(facet_raw_name()),\n                        y_lab = \"Simulated Probability\", \n                        x_lab = \"\",\n                        plot_title = variable_configuration[[x_axis_var]]$\n                            pretty_name,\n                        custom_colors = custom_outcome_colors,\n                        custom_breaks = isolate(\n                            variable_configuration[[x_axis_var]]$\n                                custom_x_breaks),\n                        custom_labels = isolate(\n                            variable_configuration[[x_axis_var]]$\n                                custom_x_labels\n                        )\n        )\n        \n        # return the plot\n        return(rp)\n    })\n    \n    # \"Single Case Mode\" dot cloud plot\n    output$dot_cloud_plot <- renderPlot({\n        # draw the plot\n        get_dot_cloud_plot(sc_likelihoods(),\n                           y_lab = \"Simulated Outcome Probability\",\n                           x_lab = \"\",\n                           custom_colors = custom_outcome_colors)\n        \n    })\n})\n\n\n\n###############################################################################\n## END OF SCRIPT\n###############################################################################",
    "created" : 1441218725900.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "114261087",
    "id" : "1160D190",
    "lastKnownWriteTime" : 1436379213,
    "path" : "C:/Projects/COS/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}